---
title: "IRI Global"
output: html_document
date: "2023-10-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Intro

This document will perform some historical analysis of different IRI thresholds against ASAP phenology active seasons.

- Globally for each active season binary raster let's calculate the #/% of pixels that are ≥ each IRI threshold of interest. Think there are two clear ways to do this:
  + Option A: Iterate through each active season binary raster masking corresponding IRI raster -> Iterate through IRI thresholds of interest (i.e 30-55) and reclassify each masked IRI raster to make a new binary raster where `TRUE` (or 1) is values ≥ threshold and `FALSE` (or 0) is values < threshold -> Zonal stats on each of the new binary raster to get #/% of pixels ≥ threshold
  + Option B: Iterate through each active season binary raster masking corresponding IRI raster -> pull all masked IRI values to a data.frame (i.e `map_dfr`) -- Then we can more efficiently/quickly play w/ different thresholds
    + I messed w/ option B -- doesn't seem feasible due to memory issues each single leadtime in a single publication date would produce
    ~ 500M rows in a data.frame.


```{r cars}
dir_pub <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "public",
  "processed",
  "glb"
)

gdb_adm0 <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "public",
  "raw",
  "glb",
  "asap",
  "reference_data",
  "gaul0_asap_v04"
)

gdf_adm0 <- st_read(gdb_adm0, layer = "gaul0_asap")

dir_priv <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "private",
  "processed",
  "glb"
)

dir_phen <-  file.path(
  dir_pub, 
  "asap",
  "season"
  )
dir(dir_phen)


dir_iri <-  file.path(
  dir_priv,
  "iri",
  "tif"
)
dir_iri_10km <-  file.path(
 dir_iri,
  "iri_tif_10km"
)


dir(dir_iri)



dir_months3 <- file.path(
  dir_phen,
  "trimester_any"
  )

r_phen_m3 <- rast(
  list.files(dir_months3,full.names = T),
  )
# load individual month active

df_phen_lookup <- tibble(
  file_name = names(r_phen_m3),
  mo_combo = str_extract_all(file_name, "\\d.*") %>% 
         unlist()
  ) %>% 
  separate(
    mo_combo,into = c("mo1","mo2","mo3"),sep = "-"
  ) %>%
  mutate(
  across(
    starts_with("mo"),~month(as.numeric(.x),label=T)
  )  
  ) %>% 
  unite("new_name",
        starts_with("mo"),
        sep = "-",remove = F) #%>% 
  

r_phen_m3 %>% 
  set.names(
    df_phen_lookup$new_name
  )

# takes a few min
r_phen_mask <- ifel(r_phen_m3 ==1, 1,NA)

# CREATE MASK -- I think we actually want to keep the 0's and 1's for the % calculations
r_phen_mask <- ifel(r_phen_m3  %in% c(0,1), 1,NA)

# is this the same as just doing
r_phen_m3_copy <-  deepcopy(r_phen_m3)
r_phen_m3_copy[r_phen_m3_copy>1] <- NA

# will this crop them pair wise?
# r_phen_masked <-  mask(r_phen_m3,r_phen_mask)

  
fp_iri <- file.path(
  dir_iri,
  "glb_iri_bavg_2023-09-16.tif"
)

# can just use a single IRI raster for now
r_phen_mask_crop <-  crop(r_phen_m3_copy,rast(fp_iri))




lr_iri_labelled <- list.files(dir_iri_10km,full.names = T) %>% 
  map(
    \(fpt)
    {
      r_tmp <- rast(fpt)
      r_tmp_lts <- r_tmp[[c("lt1","lt2","lt3","lt4")]] 
      iri_pub_date <- as_date(
        str_extract_all(basename(sources(r_tmp_lts)),
                        "\\d{4}-\\d{2}-\\d{2}") %>% 
          unlist()
      )
      mo_predicted <- floor_date(seq(iri_pub_date+months(1),iri_pub_date+months(4),by="month"),
                 "month")
      
      r_tmp_lts %>% 
        set.names(
          mo_predicted
        )
      
      cat("processing IRI ", as_date(iri_pub_date)," publication date\n")
      # I guess it's simpler to resample multi-band IRI raster here than resample each band below
      cat("resampling IRI to phenology mask resolution\n")
      r_tmp_lts_resampled <- resample(r_tmp_lts,r_phen_mask_crop)
      
      # cycle through each predicted trimester mo start name
      names(r_tmp_lts_resampled) %>% 
        map(\(mo_tmp){
          # Grab the corresponding IRI band name to make temp single band/trimester IRI raster
          r_iri_tmp <- r_tmp_lts_resampled[[mo_tmp]]
          # grab the first mo name
          mo_tmp_label <- as.character(month(mo_tmp,label=T))
          
          # use that name in lookup table to pull out equivalent phenology raster
          phenology_equivalent <- df_phen_lookup[df_phen_lookup$mo1==mo_tmp_label,]$new_name
          r_phen_equiv <- deepcopy(r_phen_mask_crop[[phenology_equivalent]])
          
          cat("masking ", iri_pub_date, "publication prediction of ", mo_tmp, " with phenology active ",mo_tmp_label)
          # now we are going to mask the IRI raster by the corresponding correct phenology raster
          # r_iri_tmp_masked <- mask(r_iri_tmp,r_phen_equiv)
          
          p_global <- ext(r_iri_tmp) %>% 
            st_bbox() %>% 
            st_as_sfc()
          st_crs(p_global) <- st_crs(r_iri_tmp)
          
          system.time(
          df_test <- seq(35,36, by=1 ) %>% 
            map(\(thresh){
              r_iri_copy<- deepcopy(r_iri_tmp)
              r_iri_copy[r_iri_copy < thresh] <- 0
              r_iri_copy[r_iri_copy >= thresh] <- 1
              r_iri_phen_mult <- r_iri_copy * r_phen_equiv
              
              # 5 s (5s *15 = ~ 1 min) to cycle through thresholds
              # 4 min 4 leadtimes per raster * 80 raster = 320 min = 5.3 hours
              system.time(
                 df_tmp_zonal <- exactextractr::exact_extract(
                r_iri_phen_mult,
                p_global,
                fun=c("sum","count")
              ) 
              )
              df_tmp_zonal %>% 
                mutate(
                  thresh= thresh,
                  pub_date= iri_pub_date,
                  predicted_start_mo = mo_tmp,
                  )
            })
          )
          
          
          # big time memory isssues here
          # df_val <- data.frame(
          #   r_iri_tmp_masked %>% 
          #   values() 
          # ) %>% 
          #   pivot_longer(everything())
          # 
          # df_val %>% 
          #   count(value)
          # 
          
          
        })
      # return(r_tmp_lts)
    }
  )







```


## Try grid mapping
```{r}

# let's see it over AFrida
library(countrycode)
gdb_adm0 <- file.path(
  Sys.getenv("AA_DATA_DIR"),
  "public",
  "raw",
  "glb",
  "asap",
  "reference_data",
  "gaul0_asap_v04"
)

gdf_adm0 <- st_read(gdb_adm0, layer = "gaul0_asap")

gdf_adm0 <- gdf_adm0 %>% 
  mutate(
    iso3 = countrycode(name0, "country.name.en", "iso3c"),
    continent = countrycode(iso3, origin = "iso3c",destination = "continent")
  )

gdf_afr <-  gdf_adm0 %>% 
  filter(continent=="Africa")


r_iri_template <- rast(file.path(
  dir_iri,
  "glb_iri_forecast_seasonal_precipitation_lower_tercile_prob_Np90Sm90Ep180Wm180_2023-09-16.tif"
))
r_iri_template[[1]] %>% 
  values() %>% 
  nrow(.)

r_iri_id_template <- deepcopy(r_iri_template[[1]])
r_iri_id_template[] <- 1:ncell(r_iri_id_template)

r_iri_grid_template_sample <- crop(r_iri_id_template,gdf_afr) 

poly_iri_grid<- as.polygons(r_iri_grid_template_sample) 
poly_iri_grid <- poly_iri_grid %>% 
  st_as_sf() %>% 
  rename(grid_id ="Tercile Probability")


iri_orig_sample <- crop(r_iri_template[[1]],gdf_afr)
library(tidyterra)
ggplot()+
  geom_sf(data=gdf_afr)+
  geom_spatraster(data= iri_orig_sample)+
  geom_sf(data=poly_iri_grid,fill=NA,color="red")
```

```{r}
# need to do this because IRI is not spatially sound - has overlapping pixels
world_bbox <- gdf_adm0 %>% 
  st_bbox() %>% 
  st_as_sfc()

r_iri_template_cropped <- crop(r_iri_template,world_bbox)

# okay all bands have same number of values - good
r_iri_template_cropped %>% 
  values() %>% 
  nrow()

r_iri_template_cropped[["grid_id"]] <- 1:ncell(r_iri_template_cropped)
r_iri_grid <-  r_iri_template_cropped[["grid_id"]]

mask(r_iri_grid,gdf_afr) %>% 
  values() %>% 
  data.frame() %>% 
  filter(!is.na(grid_id)) %>% 
  nrow()


p_iri_grid <- as.polygons(r_iri_grid) %>% 
  st_as_sf()

df_phen_grid<- exactextractr::exact_extract(
  x = r_phen_m3[[1:2]],
  y= p_iri_grid,
  fun = "sum",
  append_cols ="grid_id")

df_phen_grid %>% 
  tibble() %>% 
  pivot_wie
```

```{r}

```

